<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Person 3D Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #coords { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; background: rgba(0,0,0,0.5); padding: 5px; cursor: pointer; z-index: 1; }
        #settings-icon { position: absolute; top: 10px; right: 10px; color: white; font-size: 24px; cursor: pointer; z-index: 100; }
        #settings-panel { position: absolute; top: 50px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; display: none; z-index: 100; border-radius: 5px; font-family: Arial, sans-serif; }
    </style>
</head>
<body>
    <div id="coords">Posición: (-156.62, 20, 0)</div>
    <div id="skeleton-health" style="position: absolute; top: 60px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px;">Vida Enemigo: 100</div>
    <div id="settings-icon">⚙️</div>
    <div id="settings-panel">
        <label for="far-plane">Distancia de vista:</label><br>
        <input type="range" id="far-plane" min="100" max="2000" value="1000" step="50">
    </div>
    <div id="joystick-container" style="position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; z-index: 10;"></div>
    <div id="jump-button" style="position: absolute; bottom: 30px; right: 30px; width: 80px; height: 80px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; z-index: 10;"></div>
    <div id="attack-button" style="position: absolute; bottom: 30px; right: 120px; width: 80px; height: 80px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; z-index: 10;"></div>
    <script>
        let camera, scene, renderer, character, skeleton, coordsDiv, world, characterBody, skeletonBody, mixer, skeletonMixer, clock;
        let skeletonHealth = 100;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let characterState = 'idle';
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            clock = new THREE.Clock();

            // Physics world
            world = new CANNON.World();
            world.gravity.set(0, -100, 0);
            world.allowSleep = true; // Allow bodies to sleep

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Load map
            const loader = new THREE.GLTFLoader();
            loader.load('floating_town-hand_painted.glb', function(gltf) {
                scene.add(gltf.scene);
                gltf.scene.scale.set(20, 20, 20);

                // Update matrices
                gltf.scene.updateMatrixWorld();

                // Add collision for map using trimesh
                gltf.scene.traverse(function(child) {
                    if (child.isMesh && child.geometry) {
                        const geometry = child.geometry;
                        const positions = geometry.attributes.position.array;
                        const indices = geometry.index ? geometry.index.array : Array.from({length: positions.length / 3}, (_, i) => i);
                        const matrix = child.matrixWorld;
                        const worldPositions = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            const v = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                            v.applyMatrix4(matrix);
                            worldPositions.push(v.x, v.y, v.z);
                        }
                        const trimesh = new CANNON.Trimesh(worldPositions, indices);
                        const body = new CANNON.Body({ mass: 0 });
                        body.addShape(trimesh);
                        world.addBody(body);
                    }
                });

            }, undefined, function(error) {
                console.error(error);
            });

            // Load character
            loader.load('Knight.glb', function(gltf) {
                character = gltf.scene;
                character.position.set(0, 100, 0);
                character.scale.set(5, 5, 5);
                scene.add(character);

                // Hide specific meshes
                const meshesToHide = [
                    '1H_Sword_Offhand',
                    'Badge_Shield',
                    'Rectangle_Shield',
                    'Round_Shield',
                    'Spike_Shield',
                    'Knight_Cape',
                    'Knight_Helmet'
                ];

                character.traverse(function(child) {
                    if (child.isMesh && meshesToHide.includes(child.name)) {
                        child.visible = false;
                    }
                });

                // Animations
                mixer = new THREE.AnimationMixer(character);
                const clips = gltf.animations;
                const idleAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Idle'));
                const runningAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Running_A'));
                const jumpStartAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Start'));
                jumpStartAction.setLoop(THREE.LoopOnce);
                jumpStartAction.clampWhenFinished = true;
                const jumpIdleAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Idle'));
                const jumpLandAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Land'));
                jumpLandAction.setLoop(THREE.LoopOnce);
                jumpLandAction.clampWhenFinished = true;
                const attackAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, '1H_Melee_Attack_Slice_Horizontal'));
                attackAction.setLoop(THREE.LoopOnce);
                attackAction.clampWhenFinished = true;

                character.animationActions = { 
                    idle: idleAction, 
                    running: runningAction,
                    jump_start: jumpStartAction,
                    jump_idle: jumpIdleAction,
                    jump_land: jumpLandAction,
                    attack: attackAction
                };
                character.activeAction = idleAction;
                idleAction.play();




                // Character physics
                const characterShape = new CANNON.Sphere(1); // Use a sphere for better stability
                characterBody = new CANNON.Body({ mass: 1 });
                characterBody.addShape(characterShape);
                characterBody.position.set(-1554.91, 400.87, -145.05);
                characterBody.linearDamping = 0.9;
                characterBody.angularDamping = 1.0; // Prevent sphere from rolling
                characterBody.allowSleep = true;
                characterBody.sleepSpeedLimit = 0.1; // Body will sleep if speed is below this value
                characterBody.sleepTimeLimit = 1.0; // Body will sleep if speed is below sleepSpeedLimit for this duration
                world.addBody(characterBody);

                camera.lookAt(character.position);
            }, undefined, function(error) {
                console.error(error);
            });

            // Load skeleton
            loader.load('Skeleton_Warrior.glb', function(gltf) {
                skeleton = gltf.scene;
                skeleton.position.copy(characterBody.position);
                skeleton.position.x += 5; // offset to the side
                skeleton.position.y -= 1; // same as character adjustment
                skeleton.scale.set(5, 5, 5);
                scene.add(skeleton);

                // Hide specific meshes if needed
                skeleton.traverse(function(child) {
                    if (child.isMesh && ['Skeleton_Cape', 'Skeleton_Helmet'].includes(child.name)) { // assuming similar to knight
                        child.visible = false;
                    }
                });

                // Skeleton animations
                skeletonMixer = new THREE.AnimationMixer(skeleton);
                const skeletonClips = gltf.animations;
                const idleClip = THREE.AnimationClip.findByName(skeletonClips, 'Idle');
                const hitBClip = THREE.AnimationClip.findByName(skeletonClips, 'Hit_B');
                const deathClip = THREE.AnimationClip.findByName(skeletonClips, 'Death_A');
                skeleton.animationActions = {};
                if (idleClip) {
                    skeleton.animationActions.idle = skeletonMixer.clipAction(idleClip);
                }
                if (hitBClip) {
                    skeleton.animationActions.hit_b = skeletonMixer.clipAction(hitBClip);
                    skeleton.animationActions.hit_b.setLoop(THREE.LoopOnce);
                    skeleton.animationActions.hit_b.clampWhenFinished = true;
                }
                if (deathClip) {
                    skeleton.animationActions.death = skeletonMixer.clipAction(deathClip);
                    skeleton.animationActions.death.setLoop(THREE.LoopOnce);
                    skeleton.animationActions.death.clampWhenFinished = true;
                }
                if (skeleton.animationActions.idle) {
                    skeleton.activeAction = skeleton.animationActions.idle;
                    skeleton.activeAction.play();
                }

                // Skeleton physics
                const skeletonShape = new CANNON.Sphere(1);
                skeletonBody = new CANNON.Body({ mass: 1 });
                skeletonBody.addShape(skeletonShape);
                skeletonBody.position.copy(skeleton.position);
                skeletonBody.position.y += 1; // adjust for feet
                skeletonBody.linearDamping = 0.9;
                skeletonBody.angularDamping = 1.0;
                skeletonBody.allowSleep = true;
                skeletonBody.sleepSpeedLimit = 0.1;
                skeletonBody.sleepTimeLimit = 1.0;
                world.addBody(skeletonBody);
            }, undefined, function(error) {
                console.error(error);
            });

            // No controls, manual camera

            coordsDiv = document.getElementById('coords');
            coordsDiv.addEventListener('click', function() {
                navigator.clipboard.writeText(coordsDiv.textContent.replace('Posición: ', ''));
                alert('Coordenadas copiadas al portapapeles');
            });

            // Settings
            const settingsIcon = document.getElementById('settings-icon');
            const settingsPanel = document.getElementById('settings-panel');
            const farPlaneInput = document.getElementById('far-plane');

            settingsIcon.addEventListener('click', () => {
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            });

            farPlaneInput.addEventListener('input', (e) => {
                camera.far = parseFloat(e.target.value);
                camera.updateProjectionMatrix();
            });

            const jump = function() {
                if (characterState !== 'idle' && characterState !== 'running') return;
                const rayFrom = new CANNON.Vec3(characterBody.position.x, characterBody.position.y + 0.1, characterBody.position.z);
                const rayTo = new CANNON.Vec3(characterBody.position.x, characterBody.position.y - 1.1, characterBody.position.z);
                const result = new CANNON.RaycastResult();
                const isOnGround = world.raycastClosest(rayFrom, rayTo, {}, result);

                if (isOnGround) {
                    const jumpVelocity = 150;
                    characterBody.velocity.y = jumpVelocity;
                    characterState = 'jumping';
                }
            };

            const attack = function() {
                if (characterState === 'idle' || characterState === 'running') {
                    characterState = 'attacking';
                    // Check if skeleton is in range
                    if (skeleton && skeletonBody && skeletonHealth > 0) {
                        const distance = characterBody.position.distanceTo(skeletonBody.position);
                        if (distance < 10) { // attack range
                            skeletonHealth -= 20;
                            document.getElementById('skeleton-health').textContent = `Vida Enemigo: ${skeletonHealth}`;
                            if (skeleton.animationActions.hit_b && skeletonMixer) {
                                skeleton.activeAction.fadeOut(0.2);
                                skeleton.animationActions.hit_b.reset().fadeIn(0.2).play();
                                skeleton.activeAction = skeleton.animationActions.hit_b;
                            }
                            if (skeletonHealth <= 0) {
                                // Enemy defeated, play death animation
                                if (skeleton.animationActions.death && skeletonMixer) {
                                    skeleton.activeAction.fadeOut(0.2);
                                    skeleton.animationActions.death.reset().fadeIn(0.2).play();
                                    skeleton.activeAction = skeleton.animationActions.death;
                                }
                                document.getElementById('skeleton-health').textContent = 'Enemigo Derrotado';
                            }
                        }
                    }
                }
            };

            // Joystick and jump button for mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                const joystickContainer = document.getElementById('joystick-container');
                const jumpButton = document.getElementById('jump-button');
                const attackButton = document.getElementById('attack-button');

                const joystickOptions = {
                    zone: joystickContainer,
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white',
                    size: 120
                };
                const manager = nipplejs.create(joystickOptions);

                manager.on('move', function (evt, data) {
                    if (!data.angle) return;
                    const angle = data.angle.degree;

                    // Reset movement flags
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;

                    // Determine direction based on angle for tank controls
                    if (angle > 45 && angle < 135) {
                        moveForward = true;
                    } else if (angle > 225 && angle < 315) {
                        moveBackward = true;
                    } else if (angle >= 135 && angle <= 225) {
                        moveLeft = true; // Turn left
                    } else if (angle <= 45 || angle >= 315) {
                        moveRight = true; // Turn right
                    }
                });

                manager.on('end', function () {
                    // Stop all movement
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;
                });

                jumpButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    jump();
                });

                attackButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    attack();
                });
                
                // Hide keyboard instructions if on mobile, etc.
                // For now, we just enable the joystick.
            }

            // Event listeners for movement
            const onKeyDown = function(event) {
                if (characterBody) characterBody.wakeUp(); // Wake up on any key press
                switch(event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': jump(); break;
                    case 'KeyE': attack(); break;
                    case 'ControlLeft':
                    case 'ControlRight':
                        attack(); break;
                }
            };

            const onKeyUp = function(event) {
                switch(event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (characterBody && character && mixer) {
                // Ground check
                const groundRayFrom = new CANNON.Vec3(characterBody.position.x, characterBody.position.y + 0.5, characterBody.position.z);
                const groundRayTo = new CANNON.Vec3(characterBody.position.x, characterBody.position.y - 1.1, characterBody.position.z);
                const groundResult = new CANNON.RaycastResult();
                const isOnGround = world.raycastClosest(groundRayFrom, groundRayTo, {}, groundResult);

                // State transitions
                if (isOnGround) {
                    if (characterState === 'jumping' || characterState === 'falling') {
                        characterState = 'landing';
                    } else if (characterState !== 'landing' && characterState !== 'attacking') { // If not landing or attacking, must be idle/running
                        const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                        characterState = isMoving ? 'running' : 'idle';
                    }
                } else {
                    // In the air
                    if (characterState === 'jumping' && characterBody.velocity.y < 0) {
                        // Start falling if moving downwards after a jump
                        characterState = 'falling';
                    } else if (characterState !== 'jumping' && characterState !== 'falling' && characterState !== 'landing') {
                        // Fall if we walked off a ledge
                        characterState = 'falling';
                    }
                }

                // Determine movement speed based on ground state
                const groundMoveSpeed = 60;
                const airMoveSpeed = 30;
                const currentMoveSpeed = isOnGround ? groundMoveSpeed : airMoveSpeed;

                let moveDirection = 0;
                if (moveForward) moveDirection = 1;
                if (moveBackward) moveDirection = -1;
                
                const targetSpeed = currentMoveSpeed * moveDirection;

                // Update character state if on ground is now handled above

                // Physics update for movement
                if (targetSpeed !== 0 && characterState !== 'attacking') {
                    characterBody.wakeUp();
                    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(character.quaternion);
                    const velocity = forward.multiplyScalar(targetSpeed);
                    characterBody.velocity.x = velocity.x;
                    characterBody.velocity.z = velocity.z;
                } else {
                    // Only stop horizontal movement if on the ground
                    if (isOnGround) {
                        characterBody.velocity.x = 0;
                        characterBody.velocity.z = 0;
                    }
                }
                
                // Animation state machine
                let desiredAction;
                switch(characterState) {
                    case 'jumping': desiredAction = character.animationActions.jump_start; break;
                    case 'falling': desiredAction = character.animationActions.jump_idle; break;
                    case 'landing': desiredAction = character.animationActions.jump_land; break;
                    case 'running': desiredAction = character.animationActions.running; break;
                    case 'attacking': desiredAction = character.animationActions.attack; break;
                    default: desiredAction = character.animationActions.idle; break;
                }

                if (character.activeAction !== desiredAction) {
                    character.activeAction.fadeOut(0.2);
                    desiredAction.reset().fadeIn(0.2).play();
                    character.activeAction = desiredAction;
                }

                // Transition from landing/attacking to idle when animation finishes
                if ((characterState === 'landing' || characterState === 'attacking') && !character.activeAction.isRunning()) {
                    characterState = 'idle';
                }

                // Step physics world
                world.step(1/60);

                // Sync Three.js mesh with physics body
                character.position.copy(characterBody.position);
                character.position.y -= 1; // Adjust to make feet on ground

                if (skeleton && skeletonBody) {
                    skeleton.position.copy(skeletonBody.position);
                    skeleton.position.y -= 1; // Adjust to make feet on ground
                }

                // Tank Controls for turning
                if (characterState !== 'attacking') {
                    const turnSpeed = Math.PI; // 180 degrees per second
                    if (moveLeft) character.rotateY(turnSpeed * deltaTime);
                    if (moveRight) character.rotateY(-turnSpeed * deltaTime);
                }

                // Update camera
                const scale = character.scale.y;
                const cameraOffset = new THREE.Vector3(0, 3 * (scale/0.8), -5 * (scale/0.8));
                cameraOffset.applyQuaternion(character.quaternion);
                const newCameraPosition = character.position.clone().add(cameraOffset);
                camera.position.lerp(newCameraPosition, 0.1);
                const lookAtTarget = character.position.clone().add(new THREE.Vector3(0, 1 * (scale/0.8), 0));
                camera.lookAt(lookAtTarget);

                // Update coords display
                coordsDiv.textContent = `Posición: (${character.position.x.toFixed(2)}, ${character.position.y.toFixed(2)}, ${character.position.z.toFixed(2)})`;
            }

            if (mixer) mixer.update(deltaTime);
            if (skeletonMixer) {
                skeletonMixer.update(deltaTime);
                // Transition back to idle if hit_b finished
                if (skeleton && skeleton.activeAction === skeleton.animationActions.hit_b && !skeleton.activeAction.isRunning()) {
                    skeleton.activeAction.fadeOut(0.2);
                    skeleton.animationActions.idle.reset().fadeIn(0.2).play();
                    skeleton.activeAction = skeleton.animationActions.idle;
                }
                // Remove skeleton if death finished
                if (skeleton && skeleton.activeAction === skeleton.animationActions.death && !skeleton.activeAction.isRunning()) {
                    scene.remove(skeleton);
                    skeleton = null;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>