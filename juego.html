<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Person 3D Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #coords { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; background: rgba(0,0,0,0.5); padding: 5px; cursor: pointer; z-index: 1; }
        #settings-icon { position: absolute; top: 10px; right: 10px; color: white; font-size: 24px; cursor: pointer; z-index: 100; }
        #settings-panel { position: absolute; top: 50px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; display: none; z-index: 100; border-radius: 5px; font-family: Arial, sans-serif; }
    </style>
</head>
<body>
    <div id="coords">Posición: (-156.62, 20, 0)</div>
    <div id="fps" style="position: absolute; top: 40px; left: 10px; color: white; font-family: Arial, sans-serif; background: rgba(0,0,0,0.5); padding: 5px; z-index: 1;">FPS: 0</div>
    <div id="player-health" style="position: absolute; top: 70px; left: 10px; width: 200px; height: 20px; background: red; border: 1px solid black; z-index: 1;"><div id="player-health-bar" style="height: 100%; background: green; width: 100%;"></div></div>
    <div id="settings-icon">⚙️</div>
    <div id="settings-panel">
        <label for="far-plane">Distancia de vista:</label><br>
        <input type="range" id="far-plane" min="100" max="2000" value="1000" step="50">
        <br><label><input type="checkbox" id="ai-enemies"> Activar IA Enemigos</label>
        <br><button id="generate-enemy">Generar Enemigo</button>
    </div>
    <div id="joystick-container" style="position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; z-index: 10;"></div>
    <div id="jump-button" style="position: absolute; bottom: 30px; right: 30px; width: 80px; height: 80px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; z-index: 10;"></div>
    <div id="attack-button" style="position: absolute; bottom: 30px; right: 120px; width: 80px; height: 80px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; z-index: 10;"></div>
    <script>
        let camera, scene, renderer, character, skeleton, coordsDiv, world, characterBody, skeletonBody, mixer, skeletonMixer, clock;
        let skeletonHealth = 100;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let characterState = 'idle';
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let skeletons = []; let skeletonBodies = []; let skeletonMixers = []; let skeletonHealths = [];
        let healthDivs = []; let healthBars = [];
        let frameCount = 0;
        let physicsTime = 0;
        let fps = 0;
        let lastTime = performance.now();
        let aiEnemies = false;
        let playerHealth = 100;
        let attackTimer = 0;
        let attackCooldowns = [];

        init();
        animate();

        function spawnSkeleton(position) {
            const loader = new THREE.GLTFLoader();
            loader.load('Skeleton_Warrior.glb', function(gltf) {
                const newSkeleton = gltf.scene;
                newSkeleton.position.copy(position);
                newSkeleton.scale.set(5, 5, 5);
                scene.add(newSkeleton);

                newSkeleton.traverse(function(child) {
                    if (child.isMesh && child.name === 'Skeleton_Cape') {
                        child.visible = false;
                    }
                    if (child.isMesh && child.name === 'Skeleton_Warrior_Helmet') {
                        child.visible = true; // Show helmet initially
                    }
                });

                const newSkeletonMixer = new THREE.AnimationMixer(newSkeleton);
                const skeletonClips = gltf.animations;
                const idleClip = THREE.AnimationClip.findByName(skeletonClips, 'Idle');
                const runningClip = THREE.AnimationClip.findByName(skeletonClips, 'Running_A');
                const hitBClip = THREE.AnimationClip.findByName(skeletonClips, 'Hit_B');
                const deathClip = THREE.AnimationClip.findByName(skeletonClips, 'Death_A');
                const attackClip = THREE.AnimationClip.findByName(skeletonClips, '1H_Melee_Attack_Slice_Horizontal');
                newSkeleton.animationActions = {};
                if (idleClip) {
                    newSkeleton.animationActions.idle = newSkeletonMixer.clipAction(idleClip);
                }
                if (runningClip) {
                    newSkeleton.animationActions.running = newSkeletonMixer.clipAction(runningClip);
                }
                if (hitBClip) {
                    newSkeleton.animationActions.hit_b = newSkeletonMixer.clipAction(hitBClip);
                    newSkeleton.animationActions.hit_b.setLoop(THREE.LoopOnce);
                    newSkeleton.animationActions.hit_b.clampWhenFinished = true;
                }
                if (deathClip) {
                    newSkeleton.animationActions.death = newSkeletonMixer.clipAction(deathClip);
                    newSkeleton.animationActions.death.setLoop(THREE.LoopOnce);
                    newSkeleton.animationActions.death.clampWhenFinished = true;
                }
                if (attackClip) {
                    newSkeleton.animationActions.attack = newSkeletonMixer.clipAction(attackClip);
                    newSkeleton.animationActions.attack.setLoop(THREE.LoopOnce);
                    newSkeleton.animationActions.attack.clampWhenFinished = true;
                }
                if (newSkeleton.animationActions.idle) {
                    newSkeleton.activeAction = newSkeleton.animationActions.idle;
                    newSkeleton.activeAction.play();
                }

                const skeletonShape = new CANNON.Sphere(1);
                const newSkeletonBody = new CANNON.Body({ mass: 1 });
                newSkeletonBody.addShape(skeletonShape);
                newSkeletonBody.position.copy(newSkeleton.position);
                newSkeletonBody.position.y += 1;
                newSkeletonBody.linearDamping = 0.9;
                newSkeletonBody.angularDamping = 1.0;
                newSkeletonBody.allowSleep = true;
                newSkeletonBody.sleepSpeedLimit = 0.1;
                newSkeletonBody.sleepTimeLimit = 1.0;
                world.addBody(newSkeletonBody);

                skeletons.push(newSkeleton);
                skeletonBodies.push(newSkeletonBody);
                skeletonMixers.push(newSkeletonMixer);
                skeletonHealths.push(100);
                attackCooldowns.push(0);

                const healthDiv = document.createElement('div');
                healthDiv.style.position = 'absolute';
                healthDiv.style.width = '120px';
                healthDiv.style.height = '12px';
                healthDiv.style.background = 'red';
                healthDiv.style.border = '1px solid black';
                const healthBar = document.createElement('div');
                healthBar.style.height = '100%';
                healthBar.style.background = 'green';
                healthBar.style.width = '100%';
                healthDiv.appendChild(healthBar);
                document.body.appendChild(healthDiv);
                healthDivs.push(healthDiv);
                healthBars.push(healthBar);
            }, undefined, function(error) {
                console.error(error);
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            clock = new THREE.Clock();

            // Physics world
            world = new CANNON.World();
            world.gravity.set(0, -30, 0); // Further reduced gravity
            world.allowSleep = true; // Allow sleep to reduce calculations

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Load map
            const loader = new THREE.GLTFLoader();
            loader.load('floating_town-hand_painted.glb', function(gltf) {
                scene.add(gltf.scene);
                gltf.scene.scale.set(20, 20, 20);

                // Update matrices
                gltf.scene.updateMatrixWorld();

                // Add collision for map using trimesh
                gltf.scene.traverse(function(child) {
                    if (child.isMesh && child.geometry) {
                        const geometry = child.geometry;
                        const positions = geometry.attributes.position.array;
                        const indices = geometry.index ? geometry.index.array : Array.from({length: positions.length / 3}, (_, i) => i);
                        const matrix = child.matrixWorld;
                        const worldPositions = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            const v = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                            v.applyMatrix4(matrix);
                            worldPositions.push(v.x, v.y, v.z);
                        }
                        const trimesh = new CANNON.Trimesh(worldPositions, indices);
                        const body = new CANNON.Body({ mass: 0 });
                        body.addShape(trimesh);
                        world.addBody(body);
                    }
                });

            }, undefined, function(error) {
                console.error(error);
            });

            // Load character
            loader.load('Knight.glb', function(gltf) {
                character = gltf.scene;
                character.position.set(0, 100, 0);
                character.scale.set(5, 5, 5);
                scene.add(character);

                // Hide specific meshes
                const meshesToHide = [
                    '1H_Sword_Offhand',
                    'Badge_Shield',
                    'Rectangle_Shield',
                    'Round_Shield',
                    'Spike_Shield',
                    'Knight_Cape',
                    'Knight_Helmet'
                ];

                character.traverse(function(child) {
                    if (child.isMesh && meshesToHide.includes(child.name)) {
                        child.visible = false;
                    }
                });

                // Animations
                mixer = new THREE.AnimationMixer(character);
                const clips = gltf.animations;
                const idleAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Idle'));
                const runningAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Running_A'));
                const jumpStartAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Start'));
                jumpStartAction.setLoop(THREE.LoopOnce);
                jumpStartAction.clampWhenFinished = true;
                const jumpIdleAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Idle'));
                const jumpLandAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Jump_Land'));
                jumpLandAction.setLoop(THREE.LoopOnce);
                jumpLandAction.clampWhenFinished = true;
                const attackAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, '1H_Melee_Attack_Slice_Horizontal'));
                attackAction.setLoop(THREE.LoopOnce);
                attackAction.clampWhenFinished = true;
                const hitAction = mixer.clipAction(THREE.AnimationClip.findByName(clips, 'Hit_B'));
                hitAction.setLoop(THREE.LoopOnce);
                hitAction.clampWhenFinished = true;

                character.animationActions = {
                    idle: idleAction,
                    running: runningAction,
                    jump_start: jumpStartAction,
                    jump_idle: jumpIdleAction,
                    jump_land: jumpLandAction,
                    attack: attackAction,
                    hit: hitAction
                };
                character.activeAction = idleAction;
                idleAction.play();




                // Character physics
                const characterShape = new CANNON.Sphere(1); // Use a sphere for better stability
                characterBody = new CANNON.Body({ mass: 1 });
                characterBody.addShape(characterShape);
                characterBody.position.set(-1554.91, 400.87, -145.05);
                characterBody.linearDamping = 0.9;
                characterBody.angularDamping = 1.0; // Prevent sphere from rolling
                characterBody.allowSleep = true;
                characterBody.sleepSpeedLimit = 0.1;
                characterBody.sleepTimeLimit = 1.0;
                world.addBody(characterBody);

                camera.lookAt(character.position);

                // Load skeleton after character is loaded
                loader.load('Skeleton_Warrior.glb', function(gltf) {
                    skeleton = gltf.scene;
                    skeleton.position.copy(characterBody.position);
                    skeleton.position.x += 5; // offset to the side
                    skeleton.position.y -= 1; // same as character adjustment
                    skeleton.scale.set(5, 5, 5);
                    scene.add(skeleton);

                    // Hide specific meshes if needed
                    skeleton.traverse(function(child) {
                        if (child.isMesh && child.name === 'Skeleton_Cape') {
                            child.visible = false;
                        }
                        if (child.isMesh && child.name === 'Skeleton_Warrior_Helmet') {
                            child.visible = true; // Show helmet initially
                        }
                    });

                    // Skeleton animations
                    skeletonMixer = new THREE.AnimationMixer(skeleton);
                    const skeletonClips = gltf.animations;
                    const idleClip = THREE.AnimationClip.findByName(skeletonClips, 'Idle');
                    const runningClip = THREE.AnimationClip.findByName(skeletonClips, 'Running_A');
                    const hitBClip = THREE.AnimationClip.findByName(skeletonClips, 'Hit_B');
                    const deathClip = THREE.AnimationClip.findByName(skeletonClips, 'Death_A');
                    const attackClip = THREE.AnimationClip.findByName(skeletonClips, '1H_Melee_Attack_Slice_Horizontal');
                    skeleton.animationActions = {};
                    if (idleClip) {
                        skeleton.animationActions.idle = skeletonMixer.clipAction(idleClip);
                    }
                    if (runningClip) {
                        skeleton.animationActions.running = skeletonMixer.clipAction(runningClip);
                    }
                    if (hitBClip) {
                        skeleton.animationActions.hit_b = skeletonMixer.clipAction(hitBClip);
                        skeleton.animationActions.hit_b.setLoop(THREE.LoopOnce);
                        skeleton.animationActions.hit_b.clampWhenFinished = true;
                    }
                    if (deathClip) {
                        skeleton.animationActions.death = skeletonMixer.clipAction(deathClip);
                        skeleton.animationActions.death.setLoop(THREE.LoopOnce);
                        skeleton.animationActions.death.clampWhenFinished = true;
                    }
                    if (attackClip) {
                        skeleton.animationActions.attack = skeletonMixer.clipAction(attackClip);
                        skeleton.animationActions.attack.setLoop(THREE.LoopOnce);
                        skeleton.animationActions.attack.clampWhenFinished = true;
                    }
                    if (skeleton.animationActions.idle) {
                        skeleton.activeAction = skeleton.animationActions.idle;
                        skeleton.activeAction.play();
                    }

                    // Skeleton physics
                    const skeletonShape = new CANNON.Sphere(1);
                    skeletonBody = new CANNON.Body({ mass: 1 });
                    skeletonBody.addShape(skeletonShape);
                    skeletonBody.position.copy(skeleton.position);
                    skeletonBody.position.y += 1; // adjust for feet
                    skeletonBody.linearDamping = 0.9;
                    skeletonBody.angularDamping = 1.0;
                    skeletonBody.allowSleep = true;
                    skeletonBody.sleepSpeedLimit = 0.1;
                    skeletonBody.sleepTimeLimit = 1.0;
                    world.addBody(skeletonBody);

                    skeletons.push(skeleton);
                    skeletonBodies.push(skeletonBody);
                    skeletonMixers.push(skeletonMixer);
                    skeletonHealths.push(100);
                    attackCooldowns.push(0);
   
                    const healthDiv = document.createElement('div');
                    healthDiv.style.position = 'absolute';
                    healthDiv.style.width = '120px';
                    healthDiv.style.height = '12px';
                    healthDiv.style.background = 'red';
                    healthDiv.style.border = '1px solid black';
                    const healthBar = document.createElement('div');
                    healthBar.style.height = '100%';
                    healthBar.style.background = 'green';
                    healthBar.style.width = '100%';
                    healthDiv.appendChild(healthBar);
                    document.body.appendChild(healthDiv);
                    healthDivs.push(healthDiv);
                    healthBars.push(healthBar);
                }, undefined, function(error) {
                    console.error(error);
                });
            }, undefined, function(error) {
                console.error(error);
            });

            // No controls, manual camera

            coordsDiv = document.getElementById('coords');
            coordsDiv.addEventListener('click', function() {
                navigator.clipboard.writeText(coordsDiv.textContent.replace('Posición: ', ''));
                alert('Coordenadas copiadas al portapapeles');
            });

            // Settings
            const settingsIcon = document.getElementById('settings-icon');
            const settingsPanel = document.getElementById('settings-panel');
            const farPlaneInput = document.getElementById('far-plane');

            settingsIcon.addEventListener('click', () => {
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            });

            farPlaneInput.addEventListener('input', (e) => {
                camera.far = parseFloat(e.target.value);
                camera.updateProjectionMatrix();
            });

            const aiEnemiesCheckbox = document.getElementById('ai-enemies');
            aiEnemiesCheckbox.addEventListener('change', (e) => {
                aiEnemies = e.target.checked;
            });

            const generateEnemyButton = document.getElementById('generate-enemy');
            generateEnemyButton.addEventListener('click', () => {
                if (characterBody) {
                    const randomOffset = new THREE.Vector3((Math.random() - 0.5) * 20, 0, (Math.random() - 0.5) * 20);
                    const spawnPos = new THREE.Vector3(characterBody.position.x + randomOffset.x, characterBody.position.y + randomOffset.y, characterBody.position.z + randomOffset.z);
                    spawnSkeleton(spawnPos);
                }
            });

            const jump = function() {
                if (characterState !== 'idle' && characterState !== 'running') return;
                const rayFrom = new CANNON.Vec3(characterBody.position.x, characterBody.position.y + 0.1, characterBody.position.z);
                const rayTo = new CANNON.Vec3(characterBody.position.x, characterBody.position.y - 1.1, characterBody.position.z);
                const result = new CANNON.RaycastResult();
                const isOnGround = world.raycastClosest(rayFrom, rayTo, {}, result);

                if (isOnGround) {
                    const jumpVelocity = 150;
                    characterBody.velocity.y = jumpVelocity;
                    characterState = 'jumping';
                }
            };

            const attack = function() {
                if (characterState === 'idle' || characterState === 'running') {
                    characterState = 'attacking';
                    attackTimer = 0;
                    let closestSkeleton = null;
                    let closestDistance = Infinity;
                    let closestIndex = -1;
                    for (let i = 0; i < skeletons.length; i++) {
                        if (skeletonHealths[i] > 0) {
                            const distance = characterBody.position.distanceTo(skeletonBodies[i].position);
                            if (distance < 12 && distance < closestDistance) {
                                closestDistance = distance;
                                closestSkeleton = skeletons[i];
                                closestIndex = i;
                            }
                        }
                    }
                    if (closestSkeleton) {
                        skeletonHealths[closestIndex] -= 20;
                        if (skeletons[closestIndex].animationActions.hit_b && skeletonMixers[closestIndex]) {
                            skeletons[closestIndex].activeAction.fadeOut(0.2);
                            skeletons[closestIndex].animationActions.hit_b.reset().fadeIn(0.2).play();
                            skeletons[closestIndex].activeAction = skeletons[closestIndex].animationActions.hit_b;
                        }
                        if (skeletonHealths[closestIndex] <= 0) {
                            if (skeletons[closestIndex].animationActions.death && skeletonMixers[closestIndex]) {
                                skeletons[closestIndex].activeAction.fadeOut(0.2);
                                skeletons[closestIndex].animationActions.death.reset().fadeIn(0.2).play();
                                skeletons[closestIndex].activeAction = skeletons[closestIndex].animationActions.death;
                            }
                        }
                    }
                }
            };

            // Joystick and jump button for mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                const joystickContainer = document.getElementById('joystick-container');
                const jumpButton = document.getElementById('jump-button');
                const attackButton = document.getElementById('attack-button');

                const joystickOptions = {
                    zone: joystickContainer,
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white',
                    size: 120
                };
                const manager = nipplejs.create(joystickOptions);

                manager.on('move', function (evt, data) {
                    if (!data.angle) return;
                    const angle = data.angle.degree;

                    // Reset movement flags
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;

                    // Determine direction based on angle for tank controls
                    if (angle > 45 && angle < 135) {
                        moveForward = true;
                    } else if (angle > 225 && angle < 315) {
                        moveBackward = true;
                    } else if (angle >= 135 && angle <= 225) {
                        moveLeft = true; // Turn left
                    } else if (angle <= 45 || angle >= 315) {
                        moveRight = true; // Turn right
                    }
                });

                manager.on('end', function () {
                    // Stop all movement
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;
                });

                jumpButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    jump();
                });

                attackButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    attack();
                });
                
                // Hide keyboard instructions if on mobile, etc.
                // For now, we just enable the joystick.
            }

            // Event listeners for movement
            const onKeyDown = function(event) {
                if (characterBody) characterBody.wakeUp(); // Wake up on any key press
                switch(event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': jump(); break;
                    case 'KeyE': attack(); break;
                    case 'ControlLeft':
                    case 'ControlRight':
                        attack(); break;
                }
            };

            const onKeyUp = function(event) {
                switch(event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            fps = 1 / deltaTime;
            frameCount++;
            if (characterState === 'attacking') {
                attackTimer += deltaTime;
                if (attackTimer > 1) { // Force end attack after 1 second
                    characterState = 'idle';
                }
            }
            // Update enemy attack cooldowns
            for (let i = 0; i < attackCooldowns.length; i++) {
                if (attackCooldowns[i] > 0) {
                    attackCooldowns[i] -= deltaTime;
                }
            }

            if (characterBody && character && mixer) {
                // Ground check
                const groundRayFrom = new CANNON.Vec3(characterBody.position.x, characterBody.position.y + 0.5, characterBody.position.z);
                const groundRayTo = new CANNON.Vec3(characterBody.position.x, characterBody.position.y - 1.1, characterBody.position.z);
                const groundResult = new CANNON.RaycastResult();
                const isOnGround = world.raycastClosest(groundRayFrom, groundRayTo, {}, groundResult);

                // State transitions
                if (isOnGround) {
                    if (characterState === 'jumping' || characterState === 'falling') {
                        characterState = 'landing';
                    } else if (characterState !== 'landing' && characterState !== 'attacking') { // If not landing or attacking, must be idle/running
                        const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                        characterState = isMoving ? 'running' : 'idle';
                    }
                } else {
                    // In the air
                    if (characterState === 'jumping' && characterBody.velocity.y < 0) {
                        // Start falling if moving downwards after a jump
                        characterState = 'falling';
                    } else if (characterState !== 'jumping' && characterState !== 'falling' && characterState !== 'landing') {
                        // Fall if we walked off a ledge
                        characterState = 'falling';
                    }
                }

                // Determine movement speed based on ground state
                const groundMoveSpeed = 60;
                const airMoveSpeed = 30;
                const currentMoveSpeed = isOnGround ? groundMoveSpeed : airMoveSpeed;

                let moveDirection = 0;
                if (moveForward) moveDirection = 1;
                if (moveBackward) moveDirection = -1;
                
                const targetSpeed = currentMoveSpeed * moveDirection;

                // Update character state if on ground is now handled above

                // Physics update for movement
                if (targetSpeed !== 0 && characterState !== 'attacking') {
                    characterBody.wakeUp();
                    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(character.quaternion);
                    const velocity = forward.multiplyScalar(targetSpeed);
                    characterBody.velocity.x = velocity.x;
                    characterBody.velocity.z = velocity.z;
                } else {
                    // Only stop horizontal movement if on the ground
                    if (isOnGround) {
                        characterBody.velocity.x = 0;
                        characterBody.velocity.z = 0;
                    }
                }
                
                // Animation state machine
                let desiredAction;
                switch(characterState) {
                    case 'jumping': desiredAction = character.animationActions.jump_start; break;
                    case 'falling': desiredAction = character.animationActions.jump_idle; break;
                    case 'landing': desiredAction = character.animationActions.jump_land; break;
                    case 'running': desiredAction = character.animationActions.running; break;
                    case 'attacking': desiredAction = character.animationActions.attack; break;
                    default: desiredAction = character.animationActions.idle; break;
                }

                if (character.activeAction !== desiredAction) {
                    character.activeAction.fadeOut(0.2);
                    desiredAction.reset().fadeIn(0.2).play();
                    character.activeAction = desiredAction;
                }

                // Transition from landing/attacking/hit to idle when animation finishes
                if ((characterState === 'landing' || characterState === 'attacking' || characterState === 'hit') && !character.activeAction.isRunning()) {
                    characterState = 'idle';
                }

                // Step physics world with fixed timestep (max 1 step per frame)
                physicsTime += deltaTime;
                const timeStep = 1/30; // Physics at 30 FPS, render at 60 FPS
                if (physicsTime >= timeStep) {
                    world.step(timeStep);
                    physicsTime -= timeStep;
                }

                // Sync Three.js mesh with physics body
                character.position.copy(characterBody.position);
                character.position.y -= 1; // Adjust to make feet on ground

                for (let i = 0; i < skeletons.length; i++) {
                    if (skeletons[i] && skeletonBodies[i]) {
                        skeletons[i].position.copy(skeletonBodies[i].position);
                        skeletons[i].position.y -= 1;

                        // Dynamic helmet visibility based on health
                        const helmet = skeletons[i].getObjectByName('Skeleton_Warrior_Helmet');
                        if (helmet) {
                            helmet.visible = skeletonHealths[i] > 50;
                        }

                        // AI logic
                        if (aiEnemies && skeletonHealths[i] > 0) {
                            const distance = skeletons[i].position.distanceTo(character.position);
                            if (distance > 6) {
                                const direction = new THREE.Vector3().subVectors(character.position, skeletons[i].position).normalize();
                                const speed = 20;
                                skeletonBodies[i].velocity.x = direction.x * speed;
                                skeletonBodies[i].velocity.z = direction.z * speed;
                                skeletons[i].lookAt(character.position);
                                // Set running animation
                                if (skeletons[i].activeAction !== skeletons[i].animationActions.running) {
                                    skeletons[i].activeAction.fadeOut(0.2);
                                    skeletons[i].animationActions.running.reset().fadeIn(0.2).play();
                                    skeletons[i].activeAction = skeletons[i].animationActions.running;
                                }
                            } else {
                                skeletonBodies[i].velocity.x = 0;
                                skeletonBodies[i].velocity.z = 0;
                                // Set idle animation if not attacking
                                if (skeletons[i].activeAction !== skeletons[i].animationActions.attack && skeletons[i].activeAction !== skeletons[i].animationActions.idle) {
                                    skeletons[i].activeAction.fadeOut(0.2);
                                    skeletons[i].animationActions.idle.reset().fadeIn(0.2).play();
                                    skeletons[i].activeAction = skeletons[i].animationActions.idle;
                                }
                                if (distance < 6 && attackCooldowns[i] <= 0 && skeletons[i].activeAction !== skeletons[i].animationActions.attack) {
                                    skeletons[i].activeAction.fadeOut(0.2);
                                    skeletons[i].animationActions.attack.reset().fadeIn(0.2).play();
                                    skeletons[i].activeAction = skeletons[i].animationActions.attack;
                                }
                            }
                        }
                    }
                }

                // Tank Controls for turning
                if (characterState !== 'attacking') {
                    const turnSpeed = Math.PI; // 180 degrees per second
                    if (moveLeft) character.rotateY(turnSpeed * deltaTime);
                    if (moveRight) character.rotateY(-turnSpeed * deltaTime);
                }

                // Update camera
                const scale = character.scale.y;
                const cameraOffset = new THREE.Vector3(0, 3 * (scale/0.8), -5 * (scale/0.8));
                cameraOffset.applyQuaternion(character.quaternion);
                const newCameraPosition = character.position.clone().add(cameraOffset);
                camera.position.lerp(newCameraPosition, 0.1);
                const lookAtTarget = character.position.clone().add(new THREE.Vector3(0, 1 * (scale/0.8), 0));
                camera.lookAt(lookAtTarget);

                // Update coords display
                coordsDiv.textContent = `Posición: (${character.position.x.toFixed(2)}, ${character.position.y.toFixed(2)}, ${character.position.z.toFixed(2)})`;

                // Update FPS display
                document.getElementById('fps').textContent = `FPS: ${fps.toFixed(1)}`;

                // Update player health
                document.getElementById('player-health-bar').style.width = `${playerHealth}%`;

                // Update health bars every 10 frames for mobile performance
                if (frameCount % 10 === 0) {
                    for (let i = 0; i < skeletons.length; i++) {
                        if (skeletons[i]) {
                            const healthDiv = healthDivs[i];
                            const healthBar = healthBars[i];
                            const worldPos = skeletons[i].position.clone();
                            const screenPos = worldPos.clone();
                            screenPos.project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                            const distance = camera.position.distanceTo(skeletons[i].position);
                            const scale = Math.max(0.3, 1 - distance / 200); // Scale down with distance
                            healthDiv.style.left = `${x - 60 * scale}px`;
                            healthDiv.style.top = `${y - 150 * scale}px`;
                            healthDiv.style.width = `${120 * scale}px`;
                            healthDiv.style.height = `${12 * scale}px`;
                            const healthPercent = (skeletonHealths[i] / 100) * 100;
                            healthBar.style.width = `${healthPercent}%`;
                        }
                    }
                }
            }

            if (mixer) mixer.update(deltaTime);
            for (let i = 0; i < skeletonMixers.length; i++) {
                if (skeletonMixers[i]) {
                    skeletonMixers[i].update(deltaTime);
                    if (skeletons[i] && skeletons[i].activeAction === skeletons[i].animationActions.hit_b && !skeletons[i].activeAction.isRunning()) {
                        skeletons[i].activeAction.fadeOut(0.2);
                        skeletons[i].animationActions.idle.reset().fadeIn(0.2).play();
                        skeletons[i].activeAction = skeletons[i].animationActions.idle;
                    }
                    if (skeletons[i] && skeletons[i].activeAction === skeletons[i].animationActions.attack && !skeletons[i].activeAction.isRunning()) {
                        // Hit player if close
                        if (skeletons[i].position.distanceTo(character.position) < 6) {
                            playerHealth -= 10;
                            if (character.animationActions.hit) {
                                character.activeAction.fadeOut(0.2);
                                character.animationActions.hit.reset().fadeIn(0.2).play();
                                character.activeAction = character.animationActions.hit;
                            }
                        }
                        // Set random cooldown 1-3 seconds
                        attackCooldowns[i] = 1 + Math.random() * 2;
                        skeletons[i].activeAction.fadeOut(0.2);
                        skeletons[i].animationActions.idle.reset().fadeIn(0.2).play();
                        skeletons[i].activeAction = skeletons[i].animationActions.idle;
                    }
                    if (skeletons[i] && skeletons[i].activeAction === skeletons[i].animationActions.death && !skeletons[i].activeAction.isRunning()) {
                        scene.remove(skeletons[i]);
                        document.body.removeChild(healthDivs[i]);
                        skeletons.splice(i, 1);
                        skeletonBodies.splice(i, 1);
                        skeletonMixers.splice(i, 1);
                        skeletonHealths.splice(i, 1);
                        healthDivs.splice(i, 1);
                        healthBars.splice(i, 1);
                        attackCooldowns.splice(i, 1);
                        i--;
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
